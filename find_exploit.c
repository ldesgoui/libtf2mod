#include "all.h"


#if 0
int (*real_vsnprintf)(char *, size_t, const char *, va_list);


library_info_t *find_owning_lib(uintptr_t addr)
{
	library_info_t *lib = lib_first();
	
	do
	{
		if (addr >= lib->baseaddr &&
			addr < lib->baseaddr + lib->size) {
			return lib;
		}
	} while ((lib = lib_next(lib)) != NULL);
	
	return NULL;
}

bool addr_is_in_rodata(uintptr_t addr)
{
	library_info_t *lib = lib_first();
	
	do
	{
		if (addr >= lib->baseaddr + lib->rodata_off &&
			addr < lib->baseaddr + lib->rodata_off + lib->rodata_size) {
			return true;
		}
	} while ((lib = lib_next(lib)) != NULL);
	
	return false;
}


/* OVERRIDE: vsnprintf */
int vsnprintf(char *s, size_t n, const char *format, va_list arg)
{
	if (real_vsnprintf == NULL) {
		real_vsnprintf = dlsym(RTLD_NEXT, "vsnprintf");
	}
	
	uintptr_t fmt_addr = (uintptr_t)format;
	
	if (strstr(format, "%") == NULL) {
		if (!addr_is_in_rodata(fmt_addr)) {
			library_info_t *lib = find_owning_lib(fmt_addr);
			pr_warn("%s: found format string not in rodata!\n", __func__);
			pr_debug("  fmtstr: %08x \"%s\"\n", fmt_addr, format);
			if (lib == NULL) {
				pr_debug("  lib: none\n");
			} else {
				pr_debug("  lib: %s\n", lib->name);
			}
			BACKTRACE();
		}
	}
	
	return real_vsnprintf(s, n, format, arg);
}


#if 0
void* dlopen(const char* __file, int __mode)
{
	if (real_dlopen == NULL) {
		real_dlopen = dlsym(RTLD_NEXT, "dlopen");
	}
	
	void* handle = (*real_dlopen)(__file, __mode);
	
	if (__file != NULL && handle != NULL) {
		lib_hook(__file, handle);
	}
	
	return handle;
}
#endif

#endif
